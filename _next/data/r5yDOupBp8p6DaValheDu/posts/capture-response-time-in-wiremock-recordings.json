{"pageProps":{"title":"Capture response time in wiremock recordings","slug":"capture-response-time-in-wiremock-recordings","heroImageUrl":"//images.ctfassets.net/lybfa03y94yw/67cLyOldHSrZ3p11WX9ydJ/e223e57b570f4ec54f62f1fec66002b9/Technology___Theory__1_.jpg","description":"Wiremock provides a great recording feature to capture live flows and create stubs from them. These stubs can then be used to perform the tests without invoking dependencies. I like Wiremock's answers to imitate the actual dependency, including the response time of the dependency. Find out how wiremock can do that.","body":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"//images.ctfassets.net/lybfa03y94yw/67cLyOldHSrZ3p11WX9ydJ/e223e57b570f4ec54f62f1fec66002b9/Technology___Theory__1_.jpg\",\n    \"alt\": \"a\"\n  }))), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://wiremock.org/\",\n    \"title\": \"Wiremock\"\n  }), \"Wiremock\"), \" is a wonderful tool for mocking external dependencies for testing. I often swap out the external dependencies/services of an application with wiremock during the application load test. \"), mdx(\"p\", null, \"Wiremock provides a nice \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://wiremock.org/docs/record-playback/\",\n    \"title\": \"recording and snapshotting\"\n  }), \"recording/snapshotting\"), \" feature to capture live flows and create stubs from them. It simplifies the effort to create stubs for load tests. I run all my test cases once, record the interactions with dependencies as stubs. These stubs can then be used to perform the load test without invoking dependencies. \"), mdx(\"p\", null, \"I like Wiremock's answers to imitate the actual dependency, including the response time of the dependency. It will influence the statistics (e.g. thread waiting times) of the app under test. Wiremock, however, does not record the response time. I did not find any solution on the web, so I read through \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://wiremock.org/docs/extending-wiremock/\",\n    \"title\": \"Extending Wiremock\"\n  }), \"wiremock documentation for extensions\"), \" and came with a solution. It may not be the best or the simplest, but so far it has worked out for me. \"), mdx(\"p\", null, \"The solution has three steps. \"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Capture timestamp when the request has been received by wiremock. \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Capture timestamp when the response has been received by wiremock, from the backend system. \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Register the difference as delay in wiremock stubs. \")), mdx(\"hr\", null), mdx(\"h3\", null, \"1. Capture timestamp when the request has been received by wiremock.\"), mdx(\"p\", null, \"Wiremock provides a RequestFilter to intercept incoming requests. The CustomRequestFilter below intercepts the request and records the timestamp as a request header. This header will be used in further steps.\"), mdx(\"a\", {\n    href: \"https://gist.github.com/anuragashok/640e88d42b7ab7b69a40806f0002f337?file=CustomRequestTransformer.java\",\n    \"class\": \"embedly-card\",\n    \"data-card-width\": \"100%\",\n    \"data-card-controls\": \"0\"\n  }, \"Embedded content: https://gist.github.com/anuragashok/640e88d42b7ab7b69a40806f0002f337?file=CustomRequestTransformer.java\"), mdx(\"h3\", null, \"2. Capture timestamp when the response has been received by wiremock from the backend system.\"), mdx(\"p\", null, \"After the response is received, wiremock runs ResponseTransformers on it. This CustomResponseTransformer below determines when the response was received. It then retrieves the start timestamp from the header added in Step 1. Then the transformer calculates the response time or delay and adds it as a header in the response. \"), mdx(\"a\", {\n    href: \"https://gist.github.com/anuragashok/640e88d42b7ab7b69a40806f0002f337?file=CustomResponseTransformer.java\",\n    \"class\": \"embedly-card\",\n    \"data-card-width\": \"100%\",\n    \"data-card-controls\": \"0\"\n  }, \"Embedded content: https://gist.github.com/anuragashok/640e88d42b7ab7b69a40806f0002f337?file=CustomResponseTransformer.java\"), mdx(\"h3\", null, \"3. Record the difference as delay in wiremock stubs.\"), mdx(\"p\", null, \"Wiremock invokes StubMappingTransformer extensions, to modify StubMappings before they are saved. The CustomStubMappingTransformer below retrieves the delay from the response header added in Step 2. It then modifies the StubMapping to add the delay. The new StubMapping now has our desired request, response and also response time as a delay. \"), mdx(\"a\", {\n    href: \"https://gist.github.com/anuragashok/640e88d42b7ab7b69a40806f0002f337?file=CustomStubMappingTransformer.java\",\n    \"class\": \"embedly-card\",\n    \"data-card-width\": \"100%\",\n    \"data-card-controls\": \"0\"\n  }, \"Embedded content: https://gist.github.com/anuragashok/640e88d42b7ab7b69a40806f0002f337?file=CustomStubMappingTransformer.java\"), mdx(\"p\", null, \"The 3 extensions previously created need to be registered with wiremock. Registration can be global or per-stub base. We have to register the delay only when proxying the request to a real backend. I was using the snapshotting method, therefore, extensions were registered only with the proxy stubs. If you use the new record feature, you could enable the extensions globally and add conditional logic inside the transformers.\"), mdx(\"p\", null, \"Do \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.linkedin.com/in/anurag-ashok/\",\n    \"title\": \"Contact me @ LinkedIn\"\n  }), \"contact me\"), \", if there is a simpler solution or if you would like to discuss.\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<p><picture><source srcSet=\"//images.ctfassets.net/lybfa03y94yw/67cLyOldHSrZ3p11WX9ydJ/e223e57b570f4ec54f62f1fec66002b9/Technology___Theory__1_.jpg?fm=webp\"/><source srcSet=\"//images.ctfassets.net/lybfa03y94yw/67cLyOldHSrZ3p11WX9ydJ/e223e57b570f4ec54f62f1fec66002b9/Technology___Theory__1_.jpg\"/><img alt=\"a\" src=\"//images.ctfassets.net/lybfa03y94yw/67cLyOldHSrZ3p11WX9ydJ/e223e57b570f4ec54f62f1fec66002b9/Technology___Theory__1_.jpg\" width=\"100%\"/></picture></p><p><a href=\"http://wiremock.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Wiremock</a> is a wonderful tool for mocking external dependencies for testing. I often swap out the external dependencies/services of an application with wiremock during the application load test. </p><p>Wiremock provides a nice <a href=\"http://wiremock.org/docs/record-playback/\" target=\"_blank\" rel=\"noopener noreferrer\">recording/snapshotting</a> feature to capture live flows and create stubs from them. It simplifies the effort to create stubs for load tests. I run all my test cases once, record the interactions with dependencies as stubs. These stubs can then be used to perform the load test without invoking dependencies. </p><p>I like Wiremock&#x27;s answers to imitate the actual dependency, including the response time of the dependency. It will influence the statistics (e.g. thread waiting times) of the app under test. Wiremock, however, does not record the response time. I did not find any solution on the web, so I read through <a href=\"http://wiremock.org/docs/extending-wiremock/\" target=\"_blank\" rel=\"noopener noreferrer\">wiremock documentation for extensions</a> and came with a solution. It may not be the best or the simplest, but so far it has worked out for me. </p><p>The solution has three steps. </p><ol><li>Capture timestamp when the request has been received by wiremock. </li><li>Capture timestamp when the response has been received by wiremock, from the backend system. </li><li>Register the difference as delay in wiremock stubs. </li></ol><hr class=\"MuiDivider-root\"/><h3>1. Capture timestamp when the request has been received by wiremock.</h3><p>Wiremock provides a RequestFilter to intercept incoming requests. The CustomRequestFilter below intercepts the request and records the timestamp as a request header. This header will be used in further steps.</p><iframe width=\"100%\" frameBorder=\"0\" id=\"gist-640e88d42b7ab7b69a40806f0002f337-CustomRequestTransformer.java\"></iframe><h3>2. Capture timestamp when the response has been received by wiremock from the backend system.</h3><p>After the response is received, wiremock runs ResponseTransformers on it. This CustomResponseTransformer below determines when the response was received. It then retrieves the start timestamp from the header added in Step 1. Then the transformer calculates the response time or delay and adds it as a header in the response. </p><iframe width=\"100%\" frameBorder=\"0\" id=\"gist-640e88d42b7ab7b69a40806f0002f337-CustomResponseTransformer.java\"></iframe><h3>3. Record the difference as delay in wiremock stubs.</h3><p>Wiremock invokes StubMappingTransformer extensions, to modify StubMappings before they are saved. The CustomStubMappingTransformer below retrieves the delay from the response header added in Step 2. It then modifies the StubMapping to add the delay. The new StubMapping now has our desired request, response and also response time as a delay. </p><iframe width=\"100%\" frameBorder=\"0\" id=\"gist-640e88d42b7ab7b69a40806f0002f337-CustomStubMappingTransformer.java\"></iframe><p>The 3 extensions previously created need to be registered with wiremock. Registration can be global or per-stub base. We have to register the delay only when proxying the request to a real backend. I was using the snapshotting method, therefore, extensions were registered only with the proxy stubs. If you use the new record feature, you could enable the extensions globally and add conditional logic inside the transformers.</p><p>Do <a href=\"https://www.linkedin.com/in/anurag-ashok/\" target=\"_blank\" rel=\"noopener noreferrer\">contact me</a>, if there is a simpler solution or if you would like to discuss.</p>","scope":{}},"author":{"name":"Anurag"},"publishDate":"2021-02-07T00:00+08:00","tags":["wiremock","load test","java","delay"],"type":"blogPost"},"__N_SSG":true}