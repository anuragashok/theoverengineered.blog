<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
      <title>the_Over_Engineered_Blog</title>
      <link>https://theoverengineered.blog/</link>
      <description>the_Over_Engineered_Blog</description>
      <language>en</language>
      <lastBuildDate>Sat, 27 Feb 2021 16:00:00 GMT</lastBuildDate>
      <atom:link href="https://theoverengineered.blog/rss.xml" rel="self" type="application/rss+xml"/>
      
  <item>
    <guid>https://theoverengineered.blog/posts/publishing-my-first-artifact-to-maven-central-using-github-actions</guid>
    <title>Publishing my first artifact to maven central using GitHub actions</title>
    <link>https://theoverengineered.blog/posts/publishing-my-first-artifact-to-maven-central-using-github-actions</link>
    <description>&lt;p&gt;&lt;img src=&quot;//images.ctfassets.net/lybfa03y94yw/5aipgcfbeKO4axygu3H3lj/746c2b1c14a92ebd075d24d10986ec24/github_and_maven__1_.jpg&quot; alt=&quot;a&quot;/&gt;
&lt;!-- --&gt;&amp;lt;span&amp;gt;&lt;!-- --&gt;Photo by &lt;!-- --&gt;&amp;lt;a href=&amp;quot;https://unsplash.com/@flowforfrank?utm_source=unsplash&amp;amp;amp;utm_medium=referral&amp;amp;amp;utm_content=creditCopyText&amp;quot;&amp;gt;&lt;!-- --&gt;Ferenc Almasi&lt;!-- --&gt;&amp;lt;/a&amp;gt;&lt;!-- --&gt; on &lt;!-- --&gt;&amp;lt;a href=&amp;quot;https://unsplash.com/s/photos/programming-publish?utm_source=unsplash&amp;amp;amp;utm_medium=referral&amp;amp;amp;utm_content=creditCopyText&amp;quot;&amp;gt;&lt;!-- --&gt;Unsplash&lt;!-- --&gt;&amp;lt;/a&amp;gt;&lt;!-- --&gt;&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;I recently published a post on how to record response time with wiremock. Later, I created a java library out of it and published it on Github.&lt;/p&gt;
&lt;p&gt;I wanted to go a step further and publish the build artifacts to maven central. Fellow developers can then use them without building from source code. Some changes were needed for the project to be accepted to maven central. This post summarizes these changes and the process of automation using Github Actions.&lt;/p&gt;
&lt;h3&gt;Overall Process&lt;/h3&gt;
&lt;p&gt;The artifacts cannot be pushed to maven central directly. They first need to be deployed to the Sonatype OSSRH (OSS Repository Hosting) staging repository. Releasing from OSSRH to the maven central can then be initiated manually or via a maven plugin (more on that later). Before release, various checks are done against the project and artifacts to ensure they meet the standards of maven central. The artifacts are synced to maven central only if all the checks pass.&lt;/p&gt;
&lt;p&gt;The detailed steps for meeting the standard and publishing are as follows.&lt;/p&gt;
&lt;h3&gt;1. Create a project and request access to maven central.&lt;/h3&gt;
&lt;p&gt;Most importantly, you need an account, a project, and permission to publish to OSJRH. You will need to create an account on Sonatype JIRA and then request to create your project via a new JIRA ticket. You can also clone, edit and submit the Jira ticket I created - &lt;a href=&quot;https://issues.sonatype.org/browse/OSSRH-64328&quot; title=&quot;Sample JIRA ticket&quot;&gt;OSSRH-64328&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The group-id should follow Maven naming conventions and be the reverse of a domain you own. For projects hosted on GitHub, it can start with &lt;code&gt;com.github&lt;/code&gt; or &lt;code&gt;io.github&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The folks at sonatype were very quick in their responses and asked to create a repository on GitHub with the Jira ID as the name to verify ownership of the GitHub account. Once ownership was verified, they quickly prepared the group for publishing and deployment to the staging repository.&lt;/p&gt;
&lt;h3&gt;2. Signing Artifacts / GPG setup&lt;/h3&gt;
&lt;p&gt;One of the requirements is that the artifacts are signed with GPG. To do this, you first need to create a GPG key using the command &amp;#x27;gpg --gen-key&amp;#x27; or tools like GnuPG. You will need to enter a few details and a passphrase to remember.&lt;/p&gt;
&lt;p&gt;Once the keys are created, you need to sync the public keys with popular gpg key servers. You can synchronize the keys by retrieving the public key and then sending it to the keyservers.&lt;/p&gt;
&lt;p&gt;Example:
&lt;!-- --&gt;&amp;lt;a href=&amp;quot;https://gist.github.com/anuragashok/fab99a3db9e0cae020ce01b6ab749bb9?file=gpg.sh&amp;quot; class=&amp;quot;embedly-card&amp;quot; data-card-width=&amp;quot;100%&amp;quot; data-card-controls=&amp;quot;0&amp;quot;&amp;gt;&lt;!-- --&gt;Embedded content: https://gist.github.com/anuragashok/fab99a3db9e0cae020ce01b6ab749bb9?file=gpg.sh&lt;!-- --&gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;Once the public key is sent to one of the keyservers, it is automatically, but not immediately, synchronized with the other keyservers. You can also send it manually to the most common servers instead of waiting for synchronization. The most common servers are:&lt;/p&gt;
&lt;p&gt;hkp://pool.sks-keyservers.net&lt;br/&gt;
&lt;!-- --&gt;https://pgp.key-server.io/&lt;br/&gt;
&lt;!-- --&gt;https://keyserver.ubuntu.com/&lt;br/&gt;
&lt;!-- --&gt;https://pgp.mit.edu/&lt;br/&gt;
&lt;!-- --&gt;http://keys.gnupg.net/&lt;/p&gt;
&lt;p&gt;You can read more detailed instructions on the &lt;a href=&quot;https://central.sonatype.org/pages/working-with-pgp-signatures.html&quot; title=&quot;sonatype page on pgp signatures&quot;&gt;sonatype page on pgp signatures&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Once the GPG key is created, you need to add the following plugin to your pom to sign the artifacts.&lt;/p&gt;
&lt;p&gt;&amp;lt;a href=&amp;quot;https://gist.github.com/anuragashok/fab99a3db9e0cae020ce01b6ab749bb9?file=gpg-plugin-pom.xml&amp;quot; class=&amp;quot;embedly-card&amp;quot; data-card-width=&amp;quot;100%&amp;quot; data-card-controls=&amp;quot;0&amp;quot;&amp;gt;&lt;!-- --&gt;Embedded content: https://gist.github.com/anuragashok/fab99a3db9e0cae020ce01b6ab749bb9?file=gpg-plugin-pom.xml&lt;!-- --&gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;The pinentry-mode=loopback specification is necessary for automated builds. It tells GPG not to ask for the passphrase to be entered manually. We&amp;#x27;ll see how to provide the passphrase when we set up GitHub actions.&lt;/p&gt;
&lt;h3&gt;3. Adding metadata to the POM&lt;/h3&gt;
&lt;p&gt;Artifacts must have a minimal set of metadata before they are eligible for release to Maven Central. The metadata includes fields such as developer name, SCM URLs, licenses, etc. You can find the full list and details on the &lt;a href=&quot;https://central.sonatype.org/pages/requirements.html#sufficient-metadata&quot; title=&quot;sonatype requirements page&quot;&gt;sonatype requirements page&lt;/a&gt;. You can also reference the &lt;a href=&quot;https://github.com/anuragashok/wiremock-extension-record-delay/commit/11b6188041867dfaf936998e866cc08d7372e02d#diff-9c5fb3d1b7e3b0f54bc5c4182965c4fe1f9023d449017cece3005d3f90e8e4d8&quot; title=&quot;example pom from my project&quot;&gt;pom of my project&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;4. Generate JavaDoc and sources jar.&lt;/h3&gt;
&lt;p&gt;Maven central also requires us to generate the JavaDoc and sources jar for consumer use. This is mandatory for projects with a packaging type other than &lt;code&gt;pom&lt;/code&gt;. You can generate this by adding and configuring their respective Maven plugins to your pom.&lt;/p&gt;
&lt;p&gt;&amp;lt;a href=&amp;quot;https://gist.github.com/anuragashok/fab99a3db9e0cae020ce01b6ab749bb9?file=javadoc-source-plugin-pom.xml&amp;quot; class=&amp;quot;embedly-card&amp;quot; data-card-width=&amp;quot;100%&amp;quot; data-card-controls=&amp;quot;0&amp;quot;&amp;gt;&lt;!-- --&gt;Embedded content: https://gist.github.com/anuragashok/fab99a3db9e0cae020ce01b6ab749bb9?file=javadoc-source-plugin-pom.xml&lt;!-- --&gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;You can also see the plugins section in my &lt;a href=&quot;https://github.com/anuragashok/wiremock-extension-record-delay/commit/11b6188041867dfaf936998e866cc08d7372e02d#diff-9c5fb3d1b7e3b0f54bc5c4182965c4fe1f9023d449017cece3005d3f90e8e4d8&quot; title=&quot;example pom from my project&quot;&gt;project&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;5. Prepare POM for deployment&lt;/h3&gt;
&lt;p&gt;You need to add the URL of the distribution repository to the pom of the project. In this case, we add the staging repository as the distribution repository.&lt;/p&gt;
&lt;p&gt;&amp;lt;a href=&amp;quot;https://gist.github.com/anuragashok/fab99a3db9e0cae020ce01b6ab749bb9?file=distribution-management-pom.xml&amp;quot; class=&amp;quot;embedly-card&amp;quot; data-card-width=&amp;quot;100%&amp;quot; data-card-controls=&amp;quot;0&amp;quot;&amp;gt;&lt;!-- --&gt;Embedded content: https://gist.github.com/anuragashok/fab99a3db9e0cae020ce01b6ab749bb9?file=distribution-management-pom.xml&lt;!-- --&gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;By default, the staged artifacts must be manually from the sonatype next staging website. However, this can be automated by adding the &lt;code&gt;nexus-staging-maven-plugin&lt;/code&gt; to the project pom.&lt;/p&gt;
&lt;p&gt;&amp;lt;a href=&amp;quot;https://gist.github.com/anuragashok/fab99a3db9e0cae020ce01b6ab749bb9?file=nexus-staging-maven-plugin-pom.xml&amp;quot; class=&amp;quot;embedly-card&amp;quot; data-card-width=&amp;quot;100%&amp;quot; data-card-controls=&amp;quot;0&amp;quot;&amp;gt;&lt;!-- --&gt;Embedded content: https://gist.github.com/anuragashok/fab99a3db9e0cae020ce01b6ab749bb9?file=nexus-staging-maven-plugin-pom.xml&lt;!-- --&gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;After the artifact is deployed to the staging repository, the plugin attempts to release the artifact. If any of the checks/requirements for release are not met, the build also fails. The plugin also outputs the list of unmet requirements.&lt;/p&gt;
&lt;h3&gt;6. Automate deployment to staging and release using GitHub Actions&lt;/h3&gt;
&lt;p&gt;I use GitHub Actions as a CI CD tool. The workflow code is as follows.&lt;/p&gt;
&lt;p&gt;&amp;lt;a href=&amp;quot;https://gist.github.com/anuragashok/fab99a3db9e0cae020ce01b6ab749bb9?file=release-action.yml&amp;quot; class=&amp;quot;embedly-card&amp;quot; data-card-width=&amp;quot;100%&amp;quot; data-card-controls=&amp;quot;0&amp;quot;&amp;gt;&lt;!-- --&gt;Embedded content: https://gist.github.com/anuragashok/fab99a3db9e0cae020ce01b6ab749bb9?file=release-action.yml&lt;!-- --&gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;This workflow is triggered when I push a new tag. The workflow then builds the artifact, creates a GitHub release, and then deploys it to the staging repository. The &amp;#x27;nexus-staging-maven-plugin&amp;#x27; added in the pom automatically releases the staged artifact when all checks pass.&lt;/p&gt;
&lt;p&gt;The workflow requires a few secrets to be provided via the repository settings. More details can be found on the &lt;a href=&quot;https://docs.github.com/en/actions/reference/encrypted-secrets&quot; title=&quot;GitHub action pages&quot;&gt;GitHub action pages&lt;/a&gt;. The following secrets need to be added.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OSSRH_USERNAME&lt;/strong&gt; : the username for the sonatype Jira login&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OSSRH_PASSWORD&lt;/strong&gt;: the password for the sonatype Jira login&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OSSRH_GPG_SECRET_KEY&lt;/strong&gt;:  gpg private key ( &lt;code&gt;gpg --armor --export-secret-keys YOUR_KEY_ID&lt;/code&gt; )&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OSSRH_GPG_SECRET_KEY_PASSWORD&lt;/strong&gt; : gpg passphrase&lt;/p&gt;
&lt;h3&gt;7. Enable synchronization after first release.&lt;/h3&gt;
&lt;p&gt;This step is only needed on the first release. You need to inform the sonatype team via a comment on the project creation JIRA ticket when you release your first artifact. The sonatype team then enabled sync to maven central for the project. Once that is done, the artifact appears in maven central in about 10 mins and on the search page in a couple of hours.&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;The entire process for publishing on Maven Central seems long and complex, but most of these steps are one-time. Automating the rest with a CI CD tool makes publishing subsequent versions trivial.&lt;/p&gt;
&lt;p&gt;You can reference my project &lt;a href=&quot;https://github.com/anuragashok/wiremock-extension-record-delay&quot;&gt;wiremock-extension-record-delay&lt;/a&gt; for the complete setup.&lt;/p&gt;</description>
    <category>maven</category>
    <enclosure url="https://images.ctfassets.net/lybfa03y94yw/5aipgcfbeKO4axygu3H3lj/746c2b1c14a92ebd075d24d10986ec24/github_and_maven__1_.jpg" />
    <pubDate>Sat, 27 Feb 2021 16:00:00 GMT</pubDate>
  </item>

  <item>
    <guid>https://theoverengineered.blog/posts/capture-response-time-in-wiremock-recordings</guid>
    <title>Capture response time in wiremock recordings</title>
    <link>https://theoverengineered.blog/posts/capture-response-time-in-wiremock-recordings</link>
    <description>&lt;p&gt;&lt;img src=&quot;//images.ctfassets.net/lybfa03y94yw/67cLyOldHSrZ3p11WX9ydJ/e223e57b570f4ec54f62f1fec66002b9/Technology___Theory__1_.jpg&quot; alt=&quot;a&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wiremock.org/&quot; title=&quot;Wiremock&quot;&gt;Wiremock&lt;/a&gt; is a wonderful tool for mocking external dependencies for testing. I often swap out the external dependencies/services of an application with wiremock during the application load test.&lt;/p&gt;
&lt;p&gt;Wiremock provides a nice &lt;a href=&quot;http://wiremock.org/docs/record-playback/&quot; title=&quot;recording and snapshotting&quot;&gt;recording/snapshotting&lt;/a&gt; feature to capture live flows and create stubs from them. It simplifies the effort to create stubs for load tests. I run all my test cases once, record the interactions with dependencies as stubs. These stubs can then be used to perform the load test without invoking dependencies.&lt;/p&gt;
&lt;p&gt;I like Wiremock&amp;#x27;s answers to imitate the actual dependency, including the response time of the dependency. It will influence the statistics (e.g. thread waiting times) of the app under test. Wiremock, however, does not record the response time. I did not find any solution on the web, so I read through &lt;a href=&quot;http://wiremock.org/docs/extending-wiremock/&quot; title=&quot;Extending Wiremock&quot;&gt;wiremock documentation for extensions&lt;/a&gt; and came with a solution. It may not be the best or the simplest, but so far it has worked out for me.&lt;/p&gt;
&lt;p&gt;The solution has three steps.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Capture timestamp when the request has been received by wiremock.&lt;/li&gt;
&lt;li&gt;Capture timestamp when the response has been received by wiremock, from the backend system.&lt;/li&gt;
&lt;li&gt;Register the difference as delay in wiremock stubs.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;
&lt;h3&gt;1. Capture timestamp when the request has been received by wiremock.&lt;/h3&gt;
&lt;p&gt;Wiremock provides a RequestFilter to intercept incoming requests. The CustomRequestFilter below intercepts the request and records the timestamp as a request header. This header will be used in further steps.
&lt;!-- --&gt;&amp;lt;a href=&amp;quot;https://gist.github.com/anuragashok/640e88d42b7ab7b69a40806f0002f337?file=CustomRequestTransformer.java&amp;quot; class=&amp;quot;embedly-card&amp;quot; data-card-width=&amp;quot;100%&amp;quot; data-card-controls=&amp;quot;0&amp;quot;&amp;gt;&lt;!-- --&gt;Embedded content: https://gist.github.com/anuragashok/640e88d42b7ab7b69a40806f0002f337?file=CustomRequestTransformer.java&lt;!-- --&gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h3&gt;2. Capture timestamp when the response has been received by wiremock from the backend system.&lt;/h3&gt;
&lt;p&gt;After the response is received, wiremock runs ResponseTransformers on it. This CustomResponseTransformer below determines when the response was received. It then retrieves the start timestamp from the header added in Step 1. Then the transformer calculates the response time or delay and adds it as a header in the response.
&lt;!-- --&gt;&amp;lt;a href=&amp;quot;https://gist.github.com/anuragashok/640e88d42b7ab7b69a40806f0002f337?file=CustomResponseTransformer.java&amp;quot; class=&amp;quot;embedly-card&amp;quot; data-card-width=&amp;quot;100%&amp;quot; data-card-controls=&amp;quot;0&amp;quot;&amp;gt;&lt;!-- --&gt;Embedded content: https://gist.github.com/anuragashok/640e88d42b7ab7b69a40806f0002f337?file=CustomResponseTransformer.java&lt;!-- --&gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h3&gt;3. Record the difference as delay in wiremock stubs.&lt;/h3&gt;
&lt;p&gt;Wiremock invokes StubMappingTransformer extensions, to modify StubMappings before they are saved. The CustomStubMappingTransformer below retrieves the delay from the response header added in Step 2. It then modifies the StubMapping to add the delay. The new StubMapping now has our desired request, response and also response time as a delay.&lt;/p&gt;
&lt;p&gt;&amp;lt;a href=&amp;quot;https://gist.github.com/anuragashok/640e88d42b7ab7b69a40806f0002f337?file=CustomStubMappingTransformer.java&amp;quot; class=&amp;quot;embedly-card&amp;quot; data-card-width=&amp;quot;100%&amp;quot; data-card-controls=&amp;quot;0&amp;quot;&amp;gt;&lt;!-- --&gt;Embedded content: https://gist.github.com/anuragashok/640e88d42b7ab7b69a40806f0002f337?file=CustomStubMappingTransformer.java&lt;!-- --&gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;The 3 extensions previously created need to be registered with wiremock. Registration can be global or per-stub base. We have to register the delay only when proxying the request to a real backend. I was using the snapshotting method, therefore, extensions were registered only with the proxy stubs. If you use the new record feature, you could enable the extensions globally and add conditional logic inside the transformers.&lt;/p&gt;
&lt;p&gt;Do &lt;a href=&quot;https://www.linkedin.com/in/anurag-ashok/&quot; title=&quot;Contact me @ LinkedIn&quot;&gt;contact me&lt;/a&gt;, if there is a simpler solution or if you would like to discuss.&lt;/p&gt;</description>
    <category>wiremock load test java delay</category>
    <enclosure url="https://images.ctfassets.net/lybfa03y94yw/67cLyOldHSrZ3p11WX9ydJ/e223e57b570f4ec54f62f1fec66002b9/Technology___Theory__1_.jpg" />
    <pubDate>Sat, 06 Feb 2021 16:00:00 GMT</pubDate>
  </item>

  <item>
    <guid>https://theoverengineered.blog/posts/use-docker-for-local-development</guid>
    <title>Use Docker for local development</title>
    <link>https://theoverengineered.blog/posts/use-docker-for-local-development</link>
    <description>&lt;p&gt;&lt;img src=&quot;//images.ctfassets.net/lybfa03y94yw/31kEfTG8wIqkq8mixJ9skZ/6d86d7f4d0c700179d8eae5b31e01766/Untitled_design.jpg&quot; alt=&quot;a&quot;/&gt;
Photo by &lt;a href=&quot;https://www.pexels.com/@pixabay?utm_content=attributionCopyText&amp;amp;utm_medium=referral&amp;amp;utm_source=pexels&quot;&gt;Pixabay&lt;/a&gt; from &lt;a href=&quot;https://www.pexels.com/photo/business-coffee-composition-computer-265667/?utm_content=attributionCopyText&amp;amp;utm_medium=referral&amp;amp;utm_source=pexels&quot;&gt;Pexels&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Docker/Containers have become the de facto standard for building and deploying applications. The isolation, portability and easy scaling capabilities of containers make them the popular choice for app deployments.&lt;/p&gt;
&lt;p&gt;However, containers are not only for application deployments but can also be for local development. They can solve many developer issues. The use of Docker containers during development can have the following advantages.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;runs on my machine = runs anywhere&lt;/li&gt;
&lt;li&gt;there are no cumbersome configuration/version incompatibilities&lt;/li&gt;
&lt;li&gt;The development environment is closer to production&lt;/li&gt;
&lt;li&gt;easy onboarding of new developers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&amp;#x27;s see how I use Docker for the development of this blog.&lt;/p&gt;
&lt;h2&gt;Base Image&lt;/h2&gt;
&lt;p&gt;TheOverEngineeredBlog is built on next.js which needs node. Also, the package manager of choice is yarn. The official node image on docker hub is &lt;a href=&quot;https://hub.docker.com/_/node&quot; title=&quot;Official Node DockerHub Image&quot;&gt;here&lt;/a&gt;. It includes yarn too. This blog uses &lt;code&gt;node:lts&lt;/code&gt; image to get the latest lts version of node.&lt;/p&gt;
&lt;h2&gt;Docker Compose&lt;/h2&gt;
&lt;p&gt;I created a docker-compose.yml file at the root of the project to define the entire container configuration and add more containers if necessary later.&lt;/p&gt;
&lt;h6&gt;docker-compose.yml &lt;a href=&quot;https://github.com/anuragashok/theoverengineered.blog/blob/d784e3e072e19ae753cbe3fd39c64de86388e851/docker-compose.yml&quot; title=&quot;View on Github&quot;&gt;View on GitHub&lt;/a&gt;&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;version: &amp;#x27;3.7&amp;#x27;

services:
  runner: 
    image: node:lts
    ports: 
      - &amp;quot;$PORT:3000&amp;quot;
      - &amp;quot;$DEBUGPORT:9229&amp;quot;
    volumes:
    - .:/app:cached
    - yarn-cache-volume:/usr/local/share/.cache/yarn/v6:cached
    working_dir: /app
    command: &amp;quot;$COMMAND&amp;quot;

volumes:
  yarn-cache-volume:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The compose file defines a service named &lt;code&gt;runner&lt;/code&gt; using the base image &amp;quot;node:lts&amp;quot;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;ports&lt;/code&gt; section instructs Docker to expose ports 3000 and 9229 at $PORT and $DEBUGPORT on the host. PORT and DEBUGPORT are environment variables to configure the desired ports on the host.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;volumes&lt;/code&gt; section defines mounts and named volume. The root directory of the project is mounted to &lt;code&gt;/app&lt;/code&gt; inside the container. Also, it defines a named persistent volume for yarn cache. Docker manages this volume and persists it through the container stop/start. This cache reduces yarn execution time next time the container starts.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;working_dir&lt;/code&gt; set the current directory to &lt;code&gt;./app&lt;/code&gt; to avoid changing the directory each time the container starts.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;command&lt;/code&gt; is set to an environment variable $COMMAND. It can be supplied when invoking docker-compose.&lt;/p&gt;
&lt;h2&gt;RUN script&lt;/h2&gt;
&lt;p&gt;I like to have a &lt;code&gt;run&lt;/code&gt; script to spawn the container using docker-compose to avoid writing the same commands each time.&lt;/p&gt;
&lt;h6&gt;run &lt;a href=&quot;https://github.com/anuragashok/theoverengineered.blog/blob/d784e3e072e19ae753cbe3fd39c64de86388e851/run&quot; title=&quot;View on GitHub&quot;&gt;View on GitHub&lt;/a&gt;&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;#!/bin/sh
export PORT=${PORT:-3000}
export DEBUGPORT=${DEBUGPORT:-9229}
export COMMAND=${@:-&amp;quot;yarn dev&amp;quot;}
EXISTING_CONTAINER_ID=&amp;quot;&amp;quot;
if [ -n `docker-compose ps -q runner` ]; then
    EXISTING_CONTAINER_ID=`docker-compose ps -q runner`;
elif [ -n `docker ps -q --no-trunc | grep $(docker-compose ps -q runner)` ]; then
    EXISTING_CONTAINER_ID=`docker ps -q --no-trunc | grep $(docker-compose ps -q runner)`;
fi

if [ -z $EXISTING_CONTAINER_ID ]; then
  COMMAND=${@:-&amp;quot;yarn dev&amp;quot;} docker-compose run --service-ports --rm runner
else
  echo &amp;quot;Existing container ${EXISTING_CONTAINER_ID}&amp;quot;
  docker exec -it ${EXISTING_CONTAINER_ID} ${COMMAND}
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The script is executed like this.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;[PORT=&amp;lt;desired port on host&amp;gt; DEBUGPORT=&amp;lt;desired debug port on host&amp;gt;] ./run [&amp;lt;command&amp;gt;]

DEFAULTS PORT=3000 DEBUGPORT=9229 COMMAND=&amp;quot;yarn dev&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sections in &lt;code&gt;[]&lt;/code&gt; are optional and have defaults set.&lt;/p&gt;
&lt;p&gt;To start the application, I need to write &lt;code&gt;./run&lt;/code&gt; on the shell. It starts the container, exposing the ports 3000 and 9229 on the host and then runs &lt;code&gt;yarn dev&lt;/code&gt; inside the container.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://theoverengineered.blog/docker-local.jpg&quot; alt=&quot;Sample Output&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Any command can be executed inside the container by prefixing it with &lt;code&gt;./run&lt;/code&gt;
E.g. To add a package, run &lt;code&gt;./run yarn add some-package-name&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;You could also do &lt;code&gt;./run bash&lt;/code&gt; to get a bash shell attached to the container. This bash shell can be used to execute commands inside the container without the prefix &amp;#x27;./run&amp;#x27;&lt;/p&gt;
&lt;p&gt;The script also checks if a container is already running for the application and reuses the container to execute the command. Credits to &lt;a href=&quot;https://serverfault.com/a/935674/130937&quot; title=&quot;Check if container running&quot;&gt;this answer on ServerFault&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;We can also write a similar script for windows machines using cmd/PowerShell.&lt;/p&gt;
&lt;p&gt;This setup has helped me enormously. I don&amp;#x27;t have to worry about installing different versions of node/java/python etc. Besides, now the only dependency for local development is, Docker!&lt;/p&gt;</description>
    <category>docker container development</category>
    <enclosure url="https://images.ctfassets.net/lybfa03y94yw/31kEfTG8wIqkq8mixJ9skZ/6d86d7f4d0c700179d8eae5b31e01766/Untitled_design.jpg" />
    <pubDate>Sun, 03 Jan 2021 16:00:00 GMT</pubDate>
  </item>

  <item>
    <guid>https://theoverengineered.blog/posts/generate-rss-and-sitemap-for-nextjs-jamstack-site</guid>
    <title>Generate RSS and Sitemap for Next.js JAMstack site</title>
    <link>https://theoverengineered.blog/posts/generate-rss-and-sitemap-for-nextjs-jamstack-site</link>
    <description>&lt;p&gt;&lt;img src=&quot;//images.ctfassets.net/lybfa03y94yw/3IejIjMkhHCU5xGOwXuW5o/6e1c1a898cbcde31682db277183fba0b/GENERATE_RSS_AND_SITEMAP.png&quot; alt=&quot;a&quot;/&gt;
Image by &lt;!-- --&gt;&amp;lt;a href=&amp;quot;https://pixabay.com/users/mohamed_hassan-5229782/?utm_source=link-attribution&amp;amp;amp;utm_medium=referral&amp;amp;amp;utm_campaign=image&amp;amp;amp;utm_content=4059862&amp;quot;&amp;gt;&lt;!-- --&gt;mohamed Hassan&lt;!-- --&gt;&amp;lt;/a&amp;gt;&lt;!-- --&gt; from &lt;!-- --&gt;&amp;lt;a href=&amp;quot;https://pixabay.com/?utm_source=link-attribution&amp;amp;amp;utm_medium=referral&amp;amp;amp;utm_campaign=image&amp;amp;amp;utm_content=4059862&amp;quot;&amp;gt;&lt;!-- --&gt;Pixabay&lt;!-- --&gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;RSS and sitemap are essential for blogs today. RSS Feeds let users subscribe to your content and improves user engagement. On the other hand, a sitemap is for search engines to find and index your content.&lt;/p&gt;
&lt;p&gt;When using a CMS like wordpress etc.., the RSS and sitemap XML files are generated at runtime. However, for JAMStack websites, we would like to create them at the build stage. I was not able to find an OOTB solution for next.js to create these files. The XML files for RSS and sitemap are not too complex to generate. Hence, I decided not to introduce any third-party dependencies to generate these files.&lt;/p&gt;
&lt;p&gt;There are mainly three questions to answer when generating these files. Where, When and How?&lt;/p&gt;
&lt;h2&gt;1. Where to place&lt;/h2&gt;
&lt;p&gt;The convention followed by many is to place rss.xml and sitemap.xml at the root of the website. Sitemaps can be split into files and referenced from the main sitemap.xml. This is needed when sitemaps grow very huge. We will stick to single sitemap.xml for now.&lt;/p&gt;
&lt;p&gt;Next.js routing does not support files that are not content. So, what we can do is, to place these files in the &lt;code&gt;public&lt;/code&gt; directory. Next&amp;#x27;s static file serving feature serves the files under this directory at the root of the website.&lt;/p&gt;
&lt;h2&gt;2. When to generate&lt;/h2&gt;
&lt;p&gt;We have to generate the files inside the public directory during the build. During the build, the &lt;code&gt;getStaticProps&lt;/code&gt; function gets invoked for each page. We can leverage this function to create our XML files.&lt;/p&gt;
&lt;p&gt;We can use &lt;code&gt;getStaticProps&lt;/code&gt; function of any page component to create the files. However, this will add unnecessary code to the pages. So, I created a dummy.tsx page. The &lt;code&gt;getStaticProps&lt;/code&gt; of this page component will contain the additional build time processing logic.&lt;/p&gt;
&lt;p&gt;If anyone visits /dummy we should probably return 404 and ignore the page from any search engine indexing.&lt;/p&gt;
&lt;h6&gt;dummy.tsx &lt;a href=&quot;https://github.com/anuragashok/theoverengineered.blog/blob/1b1f462a7cb697ecdcd222313d913101de176dfa/src/pages/dummy.tsx#L15-L22&quot; title=&quot;View on GitHub&quot;&gt;View on GitHub&lt;/a&gt;&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;const Dummy: React.FC = () =&amp;gt; (
  &amp;lt;&amp;gt;
    &amp;lt;Head&amp;gt;
      &amp;lt;meta name=&amp;quot;robots&amp;quot; content=&amp;quot;noindex&amp;quot; /&amp;gt;
    &amp;lt;/Head&amp;gt;
    &amp;lt;DefaultErrorPage statusCode={404} /&amp;gt;
  &amp;lt;/&amp;gt;
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;3. How to generate&lt;/h2&gt;
&lt;p&gt;The creation of XML files is a matter of iterating over the content and generating the XML tags. This can be implemented in the &lt;code&gt;getStaticProps&lt;/code&gt; function of &lt;code&gt;pages/dummy.tsx&lt;/code&gt;. You can find the snippets of the code below. You can refer to GitHub repo for this blog for the full code sample.&lt;/p&gt;
&lt;h6&gt;dummy.tsx - getStaticProps() &lt;a href=&quot;https://github.com/anuragashok/theoverengineered.blog/blob/1b1f462a7cb697ecdcd222313d913101de176dfa/src/pages/dummy.tsx#L24-L34&quot; title=&quot;View on GitHub&quot;&gt;View on GitHub&lt;/a&gt;&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;export const getStaticProps: GetStaticProps = async () =&amp;gt; {
  const posts = await getPosts();
  generateRss(posts);

  const pages = await getAllContent();
  generateSitemap(pages);

  return {
    props: {},
  };
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h6&gt;generateRss() &lt;a href=&quot;https://github.com/anuragashok/theoverengineered.blog/blob/1b1f462a7cb697ecdcd222313d913101de176dfa/src/lib/rss.ts&quot; title=&quot;View on GitHub&quot;&gt;View on GitHub&lt;/a&gt;&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const generateRssItem = (post: Post): string =&amp;gt; `
  &amp;lt;item&amp;gt;
    &amp;lt;guid&amp;gt;${getFullUrl(`blog/${post.slug}`)}&amp;lt;/guid&amp;gt;
    &amp;lt;title&amp;gt;${post.title}&amp;lt;/title&amp;gt;
    &amp;lt;link&amp;gt;${getFullUrl(`blog/${post.slug}`)}&amp;lt;/link&amp;gt;
    &amp;lt;description&amp;gt;${post.description}&amp;lt;/description&amp;gt;
    &amp;lt;pubDate&amp;gt;${new Date(post.publishDate).toUTCString()}&amp;lt;/pubDate&amp;gt;
  &amp;lt;/item&amp;gt;
`;

export default (posts: Post[]): void =&amp;gt; {
  const rss = `&amp;lt;rss version=&amp;quot;2.0&amp;quot; xmlns:atom=&amp;quot;http://www.w3.org/2005/Atom&amp;quot;&amp;gt;
    &amp;lt;channel&amp;gt;
      &amp;lt;title&amp;gt;${SITE_TITLE}&amp;lt;/title&amp;gt;
      &amp;lt;link&amp;gt;${getFullUrl(&amp;#x27;&amp;#x27;)}&amp;lt;/link&amp;gt;
      &amp;lt;description&amp;gt;${SITE_TITLE}&amp;lt;/description&amp;gt;
      &amp;lt;language&amp;gt;en&amp;lt;/language&amp;gt;
      &amp;lt;lastBuildDate&amp;gt;${new Date(posts[0].publishDate).toUTCString()}&amp;lt;/lastBuildDate&amp;gt;
      &amp;lt;atom:link href=&amp;quot;${getFullUrl(&amp;#x27;rss.xml&amp;#x27;)}&amp;quot; rel=&amp;quot;self&amp;quot; type=&amp;quot;application/rss+xml&amp;quot;/&amp;gt;
      ${posts.map(generateRssItem).join(&amp;#x27;&amp;#x27;)}
    &amp;lt;/channel&amp;gt;
  &amp;lt;/rss&amp;gt;`;
  fs.writeFileSync(&amp;#x27;./public/rss.xml&amp;#x27;, rss);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h6&gt;generateSitemap() &lt;a href=&quot;https://github.com/anuragashok/theoverengineered.blog/blob/1b1f462a7cb697ecdcd222313d913101de176dfa/src/lib/sitemap.ts&quot; title=&quot;View on GitHub&quot;&gt;View on GitHub&lt;/a&gt;&lt;/h6&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;export default (pages: Content[]): void =&amp;gt; {
  const links = compose(map(mapToSitemapEntry))(pages);

  if (fs.existsSync(SITEMAP_PATH)) {
    fs.unlinkSync(SITEMAP_PATH);
  }
  const stream = fs.createWriteStream(SITEMAP_PATH, { flags: &amp;#x27;a&amp;#x27; });
  stream.write(`&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
  &amp;lt;urlset xmlns=&amp;quot;http://www.sitemaps.org/schemas/sitemap/0.9&amp;quot;&amp;gt;`);
  links.forEach((item) =&amp;gt; {
    stream.write(`
      &amp;lt;url&amp;gt;
        &amp;lt;loc&amp;gt;${item.url}&amp;lt;/loc&amp;gt;
        &amp;lt;changefreq&amp;gt;${item.changefreq}&amp;lt;/changefreq&amp;gt;
        &amp;lt;priority&amp;gt;${item.priority}&amp;lt;/priority&amp;gt;
      &amp;lt;/url&amp;gt;`);
  });
  stream.write(&amp;#x27;\n&amp;#x27;);
  stream.write(&amp;#x27;&amp;lt;/urlset&amp;gt;&amp;#x27;);
  stream.end();
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can later validate these xml files against the specs at &lt;a href=&quot;https://validator.w3.org/feed/&quot; title=&quot;W3C Feed Validator&quot;&gt;W3C Feed Validator&lt;/a&gt; and &lt;a href=&quot;https://www.xml-sitemaps.com/validate-xml-sitemap.html&quot; title=&quot;XML Sitemap Validator&quot;&gt;XML Sitemap Validator&lt;/a&gt;&lt;/p&gt;</description>
    <category>rss sitemap blogging jamstack nextjs</category>
    <enclosure url="https://images.ctfassets.net/lybfa03y94yw/3IejIjMkhHCU5xGOwXuW5o/6e1c1a898cbcde31682db277183fba0b/GENERATE_RSS_AND_SITEMAP.png" />
    <pubDate>Sun, 27 Dec 2020 16:00:00 GMT</pubDate>
  </item>

  <item>
    <guid>https://theoverengineered.blog/posts/initial-post</guid>
    <title>Initial Post</title>
    <link>https://theoverengineered.blog/posts/initial-post</link>
    <description>&lt;p&gt;&lt;img src=&quot;//images.ctfassets.net/lybfa03y94yw/6I30Ej62DPAl0qK3HVt38B/8e0334362cb4a2c30ffc1bb1471606d9/intial-post.jpg&quot; alt=&quot;a&quot;/&gt;
Photo by &lt;a href=&quot;https://www.pexels.com/@samuel-wolfl-628277?utm_content=attributionCopyText&amp;amp;utm_medium=referral&amp;amp;utm_source=pexels&quot;&gt;Pixabay&lt;/a&gt; from &lt;a href=&quot;https://www.pexels.com/photo/intermodal-container-stacked-on-port-1427541/?utm_content=attributionCopyText&amp;amp;utm_medium=referral&amp;amp;utm_source=pexels&quot;&gt;Pexels&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Taking a cue from &lt;a href=&quot;https://initialcommit.com/blog/What-Is-An-Initial-Commit-In-Git&quot; title=&quot;What is initial commit?&quot;&gt;Initial Commit&lt;/a&gt;, I decided to name this first post as Initial Post.&lt;/p&gt;
&lt;p&gt;I created this blog from scratch as I wanted it to also be a learning experience. This has become my hobby project where I experiment with new tools and technologies.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@gianfranconuschese/the-jamstack-return-of-the-server-side-rendering-5a1313dafc92&quot; title=&quot;Jamstack&quot;&gt;Jamstack&lt;/a&gt; is very popular these days. So decided to build this site using Jamstack practices. This post summarizes the various parts of the Jamstack eco-system used on the site.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Presentation Layer:&lt;/strong&gt; ReactJS has been on my learning list. The most popular starting points for ReactJS are create-react-app and Next.js. I eventually decided to use Next.js as it provides server-side rendering, static-site generation and serverless functions out of the box. The features can help to get the site up quickly.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;API:&lt;/strong&gt; The site does not need an API at the moment. However, Next.js provides a &lt;a href=&quot;https://nextjs.org/docs/api-routes/introduction&quot; title=&quot;NextJS solution for API routes&quot;&gt;straightforward solution&lt;/a&gt; to create APIs too.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;VCS:&lt;/strong&gt; Github.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Hosting / CDN:&lt;/strong&gt; The site runs on Github pages. It&amp;#x27;s free and fast. It provides all the features needed for now. However, I would also like to try out services like Netlify.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Backend:&lt;/strong&gt; At the moment, the site can compile to static HTML. So I am deferring this decision until the time I need a backend.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The overall architecture of the site looks like this.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/diagrams/initial-post.svg&quot; alt=&quot;Intial Architecture&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;References:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;https://medium.com/@gianfranconuschese/the-jamstack-return-of-the-server-side-rendering-5a1313dafc92&lt;/li&gt;
&lt;li&gt;https://nextjs.org/docs/api-routes/introduction&lt;/li&gt;
&lt;li&gt;https://dev.to/eroberts/why-you-should-use-netlify-instead-of-github-pages-3on1&lt;/li&gt;
&lt;/ul&gt;</description>
    <category>nextjs jamstack github github-pages react</category>
    <enclosure url="https://images.ctfassets.net/lybfa03y94yw/6I30Ej62DPAl0qK3HVt38B/8e0334362cb4a2c30ffc1bb1471606d9/intial-post.jpg" />
    <pubDate>Sat, 19 Dec 2020 16:00:00 GMT</pubDate>
  </item>

    </channel>
  </rss>